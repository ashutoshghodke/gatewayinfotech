Imagine you are in a big library ğŸ“š. You cannot carry all books at once. Instead, you ask the librarian to
give you one book at a time whenever you ask. Thatâ€™s how Python handles big collections using Iterators.

Later, instead of storing all books in memory, you ask the librarian to generate books on demand. Thatâ€™s where Generators come in.

And finally, sometimes you want to decorate the book with a nice cover ğŸ before reading. Thatâ€™s what Decorators do in Python.â€


Iterators
ğŸ“Œ Explanation:

An Iterator is an object that gives you items one at a time when you call next().

Lists, tuples, sets, etc. are iterables, but they need an iterator to go item by item.

numbers = [10, 20, 30]
it = iter(numbers)  # make iterator

print(next(it))  # 10
print(next(it))  # 20
print(next(it))  # 30


Generators
ğŸ“Œ Explanation:

A Generator is like a special function that remembers its state.

Instead of return, we use yield.

Saves memory because it produces values on demand.

def count_up_to(n):
    x = 1
    while x <= n:
        yield x   # give one value
        x += 1

gen = count_up_to(3)

print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3



Decorators
ğŸ“Œ Explanation:

A Decorator is like a gift wrapper ğŸ for a function.

It takes a function, adds some extra work, and gives back the new function.


def greet_decorator(func):
    def wrapper():
        print("ğŸ‘‹ Hello!")
        func()
        print("ğŸ‰ Bye!")
    return wrapper

@greet_decorator
def say_name():
    print("My name is MONSTER.")

say_name()



Iterator = librarian giving one book at a time.

Generator = librarian creating books only when asked.

Decorator = librarian wrapping the book in a cover before handing it.


Exception Handling
ğŸ§‘â€ğŸ« Explanation

Errors crash a program.

Exceptions let us catch problems and continue safely.



a=10
b=0
print(a/b)